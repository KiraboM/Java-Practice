import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

public class FordFulkerson{
        protected List<Integer> path;
        protected int flow;//Amount of flow passing through a particular edge
        protected int source;//Source node
        protected int sink;//Sink node
        protected boolean solved;//Checks if the max flow has been calculated
        //Used to keep track of if a node is visited
        //Node i is visited of visited[i] = visitedToken
        protected int visitedToken;
        protected int[] visited;
        protected int maxFlow;//Maximum amount of flow an edge can handle

        protected int[][] capacity;

        public FordFulkerson(Graph graph, Vertex source, Vertex sink){
            this.graph = graph;
            this.source = source;
            this.sink = sink;
        }

        //Helper method to find augmenting path from source to sink
        public Map<Vertex, Edge>findAugemtingPath(Graph graph, Vertex source, Vertex sink){
            //Use a BFS to find the augmenting path
            Map<Vertex, Edge> path = new HashMap<>();
            MyQueue<Vertex> queue = new MyQueue<>();
            queue.enqueue(source);
            path.put(source, null);
            while(!queue.isEmpty()){
                Vertex current = queue.dequeue();
                for(Edge e : current.getEdges()){
                    Vertex neighbor = e.getEndVertex();
                    if(!path.containsKey(neighbor) && e.getWeight() > 0){
                        path.put(neighbor, e);
                        queue.enqueue(neighbor);
                        if(neighbor == sink){
                            return path;
                        }
                    }
                }
            }

        }

        public int getMaxFlow(){
            int maxFlow = 0;
            while(findAugemtingPath(this.graph, this.source, this.sink) != null){
                Map<Vertex, Edge> path = findAugmentingPath(this.graph, this.source, this.sink);
                int pathFlow = Integer.MAX_VALUE;
                Vertex v = this.sink;
                while(v != this.source){
                    Edge edge = path.get(v);
                    if(edge == null){
                        break; //No path found
                    }
                    pathFlow = Math.min(pathFlow, edge.getWeight());
                    v = edge.getStartVertex();
                }
                //Augment flow along the path and update the edges
                v = this.sink
                while(v != this.source){
                    Edge edge = path.get(v);
                    if(edge == null){
                        break;
                    }
                    edge.augment(pathFlow);
                    v = edge.getStartVertex();

                }
                maxFlow += pathFlow;
            }
            return maxFlow;
        }

        public static void main(String[] args){
            Graph graph = new Graph();
            Vertex v1 = graph.addVertex(1);
        }



    }

    